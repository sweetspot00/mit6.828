# Design Document

Wanchun Ni    wanchunni@berkeley.edu

# 1 Structs

### 1.1 User struct

The user struct contains basic information about the user and also keeps its private keys. Thus only the user himself could have access to download it. It is stored into the database with a encrypt key and a MAC key generated by username and password. Its the UUID of HMAC message and the User struct is also generated by the username and password which is determined and nobody could knows except for the user. 

```go
type User struct { //need to encrypt
	Username      string
	Password      []byte
	RSAPrivateKey userlib.PKEDecKey
	DSPrivateKey  userlib.DSSignKey
	tmpFileInfo   map[string]tmpFileInfoHelper // use for append, will not save to datastore
  /*
  type tmpFileInfoHelper struct {
	fileInfoId          userlib.UUID
	fileInfoMasterKey   []byte
	fileInfoMACID       userlib.UUID
	fileInfo            FileInfo
	lastBlockInfoHelper BlockInfoHelper
}
  */
}
```

1. **Username**: Not encrypted because it is not insecure to expose.
2. **Password**: `userlib.Hash(userlib.Hash(append([]byte(password), []byte(username)...)))` Saved as hash bytes, salt is the username.
3. **RSAPrivateKey**: Asymmetric encryption private key, using in sharing files.
4. **DSPrivateKey**: Integrity check for asymmetric encryption, using in sharing files.
5. **tmpFileInfo**: Using in append to decrease bandwidth. It will not save to the data store.

### 1.2 File Saving Structure

Preview:

<img src="/Users/niwanchun/Documents/ucb_21fall/cs161/proj/fa21-project2-onlyme/未命名文件.jpg" alt="未命名文件" style="zoom:65%;" />

#### 1.2.1 User Owned File Info

This struct is used to save the file information which is owned by the user.

```golang
type UserOwnedfileInfo struct { /// id = by filename and username, mac id  = filename and user name, key by filename and username
	FileInfoUUID      userlib.UUID
	FileInfoMACUUID   userlib.UUID
	FileInfoMasterKey []byte
}
```

The struct id in the data store is determined by username and filename, which means that this struct will create whenever storing a new file. Also, this struct will be encrypted and it's encryption key is also generated from username and filename. The MAC message is also saved in the datastore in a deterministic way. In this way only the file owner himself can visit this struct and get the file information. The information saved in the struct is used to decrypt as well as verify the next layer's information.

1. **FileInfoUUID**: The UUID of the file info struct where stores the real file information.
2. **FileInfoMACUUID**: The UUID of the file info MAC message.
3. **FileInfoMasterKey**: The master key for generating a series of keys of the next layers usage.

#### 1.2.2 User Shared File Info

This struct is used to save the share file infomation which is related to the file shared by others.

```go
type UserSharedFileInfo struct { // id = by filename and username, mac id  = filename and user name, key by filename and username
	ShareFileID  userlib.UUID
	RootName     string
	SharedByName string
}
```

The encryption schema  of this struct is same to User owned file info. It can also use username and filename to achieve this struct only by the user himself. 

1. **ShareFileID**: The ShareFile Struct ID in the data store, which is also the pointer the owner gave to the recipient when sharing files.
2. **RootName**: The share file's original owner name.
3. **SharedByName**: The name of the sender of the invitation.

Those messages are used to verify the *ShareFile* struct's integrity.

#### 1.2.3 ShareFile Struct

The *ShareFile* struct is a medium layer between owned file info (share file info) which can be directly visit using username and filename and *FileInfo* layer which is can only be retrieved as well as decrypted by the last layer's infomation.

```go
type ShareFile struct { //
	RealFileInfo []byte // not encrypted, marshal HelperShareFile to bytes
  /*
  type HelperShareFile struct {
	EncryptedKey      []byte // using public key encrypt the symmetric key
	EncryptedFileInfo []byte // using symmetric key to encrypt FileInfoStruct UUID and MasterKey,(FileInfoStruct UUID, key, macID)
}
  */
	RootName     string //only used once, then store in user, because it could be modified
	RootDS       []byte //root signature of fileInfo
	SharedByDS   []byte // only used once when accepting invitation
}
```

1. **RealFileInfo**: Information used to get and decrypt FileInfo.
2. **RootName**: The file's owner name. 
3. **RootDS**: The digital signature of the owner signing real file info.
4. **SharedByDS**: The digital signature of the sender signing the first three fields.

#### 1.2.4 FileInfo Struct

The *FileInfo* struct saves the most important information about the file. Such that it is encrypted by the keys generated from *FileInfoMasterKey*, which can get from last layer. 

```go
type FileInfo struct { // need to encrypt
	FirstInfoBlockID userlib.UUID // the first fileInfoBlock ID
	LastInfoBlockID  userlib.UUID
	Owner            string //owner's user name
	SharedTo         map[string]map[string]userlib.UUID
	FirstDecKey      []byte
	FirstMacKey      []byte
	LastDecKey       []byte
	LastMacKey       []byte
}
```

1. **FirstInfoBlockID**: Next layer is the block information which is used to locate and decrypt the file block. This Id is the first block information id.
2. **LastInfoBlockID** : The last block infomation ID.
3. **Owner**: The file owner's username.
4. **SharedTo**: The sharing map.
5. **FirstDecKey**: The first block information decryption key.
6. **FirstMacKey**: The first block infomation MAC key.
7. **LastDecKey**: The last block information decryption key.
8. **LastMacKey**: The last block information MAC key.

#### 1.2.5 Block Info Struct

The *Block Info* struct is a linked list which saves the information used to decrypt the real file content. Its main information is  encrypted and and can be decrypted by the last block info or the file info(the first block).

```go
type BlockInfo struct {
	EncBlockInfoHelper []byte
  /*
  type BlockInfoHelper struct { //encrypt by last key and mac
	HasNext             bool
	BlockId             userlib.UUID
	BlockEncKey         []byte
	BlockMacKey         []byte
	NextBlockInfoID     userlib.UUID
	NextBlockInfoEncKey []byte
	NextBlockInfoMacKey []byte
}
  */
	ThisBlockMacMsg    []byte
}
```

1. **EncBlockInfoHelper**: This field is the encrypted information containing the file block id, the key to decrypt the block as well as the keys of decrypting next block info.
2. **ThisBlockMacMsg**: Used for validation of integrity of the *EncBlockInfoHelper*.

#### 1.2.6 File Block Struct

The *FileBlock* struct is used to store the real file content. It is encrypted and can be decrypted by the keys from last layer.

```go
type FileBlock struct {
	Content []byte //only need to encrypt content
	HMAC    []byte // hmac message 
}
```

1. **Content**: The encrypted file content.
2. **HMAC**: The MAC message of *Content*.

# 2 System Design

### 2.1 How is a file stored on the server?

+ Store a new file

  According to the preview of file saving structure, whenever storing a new file, **4 new structs** will be created and saved to the datastore.

  1. Init **FileInfo**

     First init the basic message used to find and encrypt as well as validate the *FileInfo*. Specifically, generate new *fileInfoUUID*(randomly), *fileInfoMasterKey*(randomly), *fileInfoMACUUID*(randomly).

  2. Generate **UserOwnedFileInfo** and save

     Save the initial fileInfo message created in the last step into a new *UserOwnedFileInfo* struct. Then encrypt the struct and save the encrypted message as well as MAC message into the data store.

     Specifically, the key used to encrypt the *UserOwnedFileInfo* and the pointer of the struct as well as MAC  is generated in a deterministic way as follows.

     ```go
     	originalKey := userlib.Argon2Key([]byte(userlib.Hash([]byte(filename))), []byte(userdata.Username), 16)
     
     	encKey, _ := userlib.HashKDF(originalKey, []byte("enc"))
     	encKey = encKey[:16]
     
     	macKey, _ := userlib.HashKDF(originalKey, []byte("mac"))
     	macKey = macKey[:16]
     
     	// generate ID
     	userOwnedfileInfoId, _ := userlib.UUIDFromBytes(userlib.Hash(append(userlib.Hash([]byte(filename+"id")), userlib.Hash([]byte(userdata.Username))...)))
     	userOwnedfileInfoMacId, _ := userlib.UUIDFromBytes(userlib.Hash(append(userlib.Hash([]byte(filename+"mac")), userlib.Hash([]byte(userdata.Username))...)))
     ```

  3. Generate **FileBlock** and **BlockInfo**

     Given the FileinfoMasterKey, new keys to encrypt the file block can be derivated from the master key. Using the new keys to encrypt the file content and also save the MAC message into the file block. Then save the *fileBlock*'s UUID and the new keys into the *BlockInfo*. Becauese when saving a new file, there will only be one block, such that the linked list will only have the head. To complete creating *BlockInfo*, the next step is to generate the next pointer(UUID) of the linked list's next item as well as its encryption and MAC keys. The `HasNext`field in `blockInfoHelper` is set to `false`. Using randomly generated keys to encrypt this *BlockInfo* and save the Id and keys into *FileInfo*.

  4. Complete **FileInfo**

     Because the *BlockInfo* is the first as well as the last *BlockInfo* really exists in the datastore, the `FirstInfoBlock` and `LastInfoBlock` fields in the *FileInfo* are the same. Then derivate keys from *fileInfoMasterKey* to encrypt *FileInfo* and save it to the data store. 

     Specifically, the keys used to encrypt *FileInfo* is generated as follows.

     ```go
     	fileInfoEncKey, _ := userlib.HashKDF(fileInfoMasterKey, []byte("fileInfoContentEncrypt")) //determine
     	fileInfoEncKey = fileInfoEncKey[:16]
     	fileInfoMacKey, _ := userlib.HashKDF(fileInfoMasterKey, []byte("fileInfoContentMac"))
     	fileInfoMacKey = fileInfoMacKey[:16]
     ```

+ Overwrite a file

  - Overwrite an owned file

    Because this file already exists, there's no need to generate new structs. 

    1. Decrypt **UserOwnedFileInfo**

       Using the keys that were only determined by username and filename to decrypt the *UserOwnedFileInfo* struct and get the *fileInfoID*, *fileInfoMasterKey*, *fileInfoMacID*.

    2. Decrypt **FileInfo**

       Using message from last layer to get the file blocks information (after validation).

    3. Generate new **FileBlock** and **BlockInfo**

       To simplify the steps, old file blocks were abandoned and new *FileBlock* and *BlockInfo* was generated (identical steps in *Store a new file*). The related new messages were also saved to the old *FileInfo*.

    4. Encrypt **FileInfo** and Save

  - Overwrite a shared file

    1. Decrypt **UserSharedFileInfo**

       Using the keys that were only determined by username and filename to decrypt the *UserSharedFileInfo* struct and get the *ShareFileID*.

    2. Using **ShareFile** to get **FileInfo** entry and keys

       *ShareFile* struct saves information about *FileInfo*. Because it is shared from another user, the message can be verified through root's public key and decrypted through user's private key. 

    3. Same steps as *Overwrite an owned file* 3-4.

### 2.2 How does a file get shared with another user?

Preview:

<img src="/Users/niwanchun/Documents/ucb_21fall/cs161/proj/fa21-project2-onlyme/2.jpg" alt="2" style="zoom: 45%;" />

+ Share an owned file

  1. Get file information

     According to saving files, the most important way of getting to a file is knowing its *fileInfoID*, *fileInfoMasterKey*, *fileInfoMACID*. These messages can be got from **UserOwnedFileInfo**. The step of how to decrypt is identical to the first step in *Overwrite an owned file*.

  2. Generate a new **ShareFile** struct

     Generate a symmetric key to encrypt the file information mention in step one. Encrypt the symmetric key with the recipient's public key. These two messages construct the *realFileInfo* field. Then the owner sign the *realFileInfo* and save the signature to the *RootDS* field. Because this file is sent by the owner, the sharedByDS is also the signature of the owner. However, it is the signature of the whole *ShareFile* struct excluding the signature itself, which is different from *RootDS*.

  3. Give the new **ShareFile** id to the recipient.

  4. Receiver generates **UserSharedFileInfo**

     The receiver will first validate if the *ShareFile* struct comes from the legitimate sender by using the digital signature from sender and its public key. Then using the owner's public key to verify the real file info has not been modified. It is worth mentioning that the sender's signature will only be used once when accepting the invitation. Then the sender will create a new *UserSharedFileInfo* and save the *ShareFileId* (the invitation pointer) and the owner's name into it. The *UserShareFileInfo* is totally confident to others and can only be decrypt by the filename and username (the way of encrypting it is same to *UserOwnedFileInfo* which has been stated in 2.1), thus information in the *UserSharedFileInfo* can keep integrity. (this will be useful in revoke access)

  5. Update the *ShareTo* map in **FileInfo**

+ Share a shared file

  1. Decrypt **UserSharedFileInfo** and get to the **ShareFile**. 

  2. Verify the *ShareFile*'s real file info by using the owner's public key and the *RootDS*. 

  3. Decrypt the symmetric key using user's private key and then decrypt the file info messages.

  4. Generate a new **ShareFile** struct, same as *step 2 in Share an owned file* except for the *RootDS* was copied from the sender's *ShareFile*.

  5. Same steps as step 3-5 in "Share an owned file".

     

### 2.3 What is the process of revoking a user's access to a file?

1. Get to the FileInfo from *UserOwnedFileInfo* and get the shareTo map. Delete the recipient information in the shareTo map. Get the old content by iterating all the file blocks (client.LoadFile). Generate new Block info and new File block to save the old content into one block (same as store file). 

2. Generate new *FileInfo* struct (same as store file). Update the shareTo field with the deleted one. Update other information with the new block info. Save the new *fileInfoID*, *fileInfoMasterKey*, *fileInfoMacID* into **UserOwnedFileInfo**.

3. Broadcast the new file info to the users who still have access to the file using the new shareTo map.

   The shareTo map will save all the receiver's *ShareFile* ID. The owner will then update the real file info and re-sign it in all the *ShareFile* structs. However, the original senders signature will stay the same because the owner doesn't have access to their private keys. As a result, whenever the user try to get the information from *ShareFile* except the time when they accecpt the invitation, they will only using *RootDS* to verify the integrity.

   

### 2.4 How does your design support file append?

1. Get decrypted **FileInfo** from either *UserOwnedFileInfo* or *UserSharedFileInfo*. 
2. Get to the last block info using information from *FileInfo*. Update the `HasNext` field to `true` and using the *NextBlockInfoID* to generate a new *BlockInfo* as the new last block info.
3. Generate a new file block to save the append file content. Save the encryption and MAC keys into the new block info.
4. Generate new next block info pinter as well as new next block encryption messages (encryption key and MAC key). Save these messages into the new last block info.
5. Using keys from the old last block info to encrypt the new last block info and save it to the data store.
6. The *tmpFileInfoHelper* field in User struct is used to save temporary file blocks infomation. When continuing appending files within a same user instance, messages could be read directly from the User struct instead of loading it from the data store.

In conclusion, when appending a file. Only need to download *UserOwnedFileInfo* (*UserSharedFileInfo*), *FileInfo*, *Last Block Info*; upload *Old Last Block Info*, *New Last Block Info*, *New File Block*, *File Info*. Because those structs's sizes are not related to the files the user save which means the append bandwidth will be constant.

# 3 Security Analysis

1. Man in the middle attack

   When sharing the file, there's a possibility for a third party to intercept with the message. My design can handle this kind of attack because during the sharing, the sender will sign the message to insure it is send by himself. If it is modified, then the system will detect and throw an error.

2. Compromise the DataStore

   Since the DataStore is not secure, it might be attacked by malicious attacker. However, my design can protect confidentiality of all the data because all the data is saved as encryption message. The original encryption key is calculated everytime the user log in and will not save into the DataStore. The key is only known by the user himself.

3. Revoked User could become malicious

    Since the user could use debugger tools to get the local variables. Every time the root revokes somebody's access, the corresponding file info and related keys has been changed. Even if the attacker records the variables before, he cannot visit the files through the pointer because the file is not there any more.

4. Swapping to identical files

   Since all the file block keys are different, even though swapping two identical files, the system can detect the modification and throw an error.

5. Steal other's invitation pointer

   The *ShareFile* every receiver got was uniquely encrypted by the receiver's public key and can only be decrypted by the private key. When accepting the invitation, the client side will try to decrypt the real file message and then it will discover that this pointer doesn't belong to the fake receiver.

6. Data store modification

   There's a possibility that the attacker will modify the data store directly. However, every struct saved to the data store is encrypted and has its MAC messages or digital signature. Whenever the data store is modified, the client API will detect the modification and throw an error.

